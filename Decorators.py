# ДЕКОРАТОРЫ

# Декораторы можно представить себе как функции, которые меняют функциональность другой функции.
# Они помогают сделать Ваш код короче, а также по стилю более похожим на стиль Python.

# Любой элемент в Python - это объект.
# Это значит, что функции - это объекты, которым можно дать имена (labels) и передавать в другие функции.

# Создадим простую функцию
def hello(name='Denis'):
    return 'Hello '+name

# Присвоим другое имя (label) этой функции.
# Обратите внимание, что здесь мы не используем скобки, потому что не вызываем функцию hello.
# Вместо этого мы передаем объект-функцию в переменную greet.
greet = hello

# Что случится, если мы удалим имя hello?
del hello
# print(hello()) - это выдаст ошибку, так как функции hello() больше не существует
# Но несмотря на то, что мы удалили имя hello, имя greet по-прежнему указывает на объект функции.
# Очень важно знать, что функции это объекты, которые можно передавать другим объектам!
print(greet()) # Hello Denis

# Функции внутри функций

def hello(name='Denis'):
    print('Запущена функция hello()')

    def greet():
        return '\t Мы находимся внутри функции greet()'

    def welcome():
        return "\t Мы находимся внутри функции welcome()"

    print(greet())
    print(welcome())
    print("Теперь мы вернулись в функцию hello()")

hello()
# Вызов функций greet() и welcome() вне функции hello() выдаст ошибку.
# Так как из-за области видимости функция welcome() и greet() не определена вне функции hello()

# Возврат функций

def hello(name='Denis'):
    def greet():
        return '\t Мы находимся внутри функции greet()'

    def welcome():
        return "\t Мы находимся внутри функции welcome()"

    if name == 'Denis':
        return greet
    else:
        return welcome

# Eсли мы установим x = hello(), будет возвращена функция greet
x = hello()
# x указывает на функцию greet внутри функции hello.
print(x()) # Вывод: Мы находимся внутри функции greet()

# В операторе if/else мы возвращаем greet и welcome, а не greet() и welcome().
# Это потому что когда мы пишем скобки после названия функции, то запускаем эту функцию.
# Однако, когда мы не пишем скобки, то мы можем передавать эту функцию, не запуская её.
# Когда мы пишем x = hello(), то запускается функция hello(), и поскольку по умолчанию name равно Denis,
# то возвращается функция greet. Если мы поменяем команду на x = hello(name = "Sam"), то вернется функция welcome.
# Мы также можем сделать print(hello()()), и это вернет Мы находимся внутри функции greet().

# Функции как параметры

# Мы можем передавать функции как объекты, и затем использовать их внутри других функций.
def hello():
    return 'Hi Denis!'

def other(func):
    print('Здесь будет указан другой код')
    print(func())

other(hello)

# Создание декоратора

def new_decorator(func):

    def wrap_func():
        print("Здесь находится код, до запуска функции")

        func()

        print("Этот код запустится после функции func()")

    return wrap_func

def func_needs_decorator():
    print("Для этой функции нужен декоратор")

func_needs_decorator()

# Переопределяем func_needs_decorator
func_needs_decorator = new_decorator(func_needs_decorator)
func_needs_decorator()

# Декоратор здесь служит оберткой функции, поменяв её поведение.
# Теперь посмотрим, как можно переписать этот код с помощью символа @, который используется в Python для декораторов:
@new_decorator
def func_needs_decorator():
    print("Для этой функции нужен декоратор")

func_needs_decorator()